/* Code Pulse: a real-time code coverage tool, for more information, see <http://code-pulse.com/>
 *
 * Copyright (C) 2014-2017 Code Dx, Inc. <https://codedx.com/>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.codedx.codepulse.agent.message;

import java.io.IOException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;

import com.codedx.bytefrog.instrumentation.id.*;

import com.codedx.codepulse.agent.common.message.MessageProtocol;
import com.codedx.codepulse.agent.common.queue.DataBufferOutputStream;

/**
 * An object that is responsible for sending data messages according to
 * protocol. Messages are written to buffers which are provided by a
 * {@link BufferService}, then sent via the same BufferService. For events that
 * require mapped ids for the current thread and method signature, those ids
 * (along with the appropriate secondary "map" events) will be automatically
 * generated by an internal {@link MethodId} and {@link ThreadId}. The time of
 * MessageFactory's construction will be saved, and used to calculate the
 * "relative timestamp" for each event that requires one.
 *
 * @author dylanh
 */
public class MessageDealer
{
	private final MessageProtocol messageProtocol;
	private final BufferService bufferService;

	private final long startTime = System.currentTimeMillis();
	private final ExceptionId exceptionIdMapper = new ExceptionId();
	private final ThreadId threadIdMapper = new ThreadId();
	private final Sequencer sequencer = new Sequencer();

	private final MethodIdAdapter methodIdAdapter;

	/**
	 *
	 * @param messageProtocol
	 * @param bufferService
	 */
	public MessageDealer(MessageProtocol messageProtocol, BufferService bufferService, ClassIdentifier classIdentifier, MethodIdentifier methodIdentifier)
	{
		this.messageProtocol = messageProtocol;
		this.bufferService = bufferService;

		methodIdAdapter = new MethodIdAdapter(classIdentifier, methodIdentifier);
	}

	// just a helper method, used internally
	protected int getTimeOffset()
	{
		return (int) (System.currentTimeMillis() - startTime);
	}

	/**
	 * Observes (returns) the next sequencer ID, without incrementing.
	 *
	 * @returns the next sequencer ID
	 */
	public int getCurrentSequence()
	{
		return sequencer.observeSequence();
	}

	// ===============================
	// API METHODS:
	// ===============================

	/**
	 * MAP EXCEPTION (EVENT) MESSAGE
	 *
	 * @param exception
	 * @param id
	 * @throws IOException
	 * @throws FailedToObtainBufferException
	 * @throws FailedToSendBufferException
	 */
	public void sendMapException(String exception, int id) throws IOException,
			FailedToObtainBufferException, FailedToSendBufferException
	{
		DataBufferOutputStream buffer = bufferService.obtainBuffer();
		if (buffer != null)
		{
			boolean wrote = false;
			try
			{
				messageProtocol.writeMapException(buffer, id, exception);
				wrote = true;
			}
			finally
			{
				if (!wrote)
					buffer.reset();
				bufferService.sendBuffer(buffer);
			}
		}
	}

	/**
	 * MAP THREAD NAME (EVENT) MESSAGE
	 *
	 * @param name
	 * @param id
	 * @throws IOException
	 * @throws FailedToObtainBufferException
	 * @throws FailedToSendBufferException
	 */
	public void sendMapThreadName(String name, int id) throws IOException,
			FailedToObtainBufferException, FailedToSendBufferException
	{
		DataBufferOutputStream buffer = bufferService.obtainBuffer();
		if (buffer != null)
		{
			boolean wrote = false;
			try
			{
				messageProtocol.writeMapThreadName(buffer, id, getTimeOffset(), name);
				wrote = true;
			}
			finally
			{
				if (!wrote)
					buffer.reset();
				bufferService.sendBuffer(buffer);
			}
		}
	}

	/**
	 * METHOD ENTRY (EVENT) MESSAGE
	 *
	 * @param methodId
	 * @throws IOException
	 * @throws FailedToObtainBufferException
	 * @throws FailedToSendBufferException
	 */
	public void sendMethodEntry(int methodId) throws IOException,
			FailedToObtainBufferException, FailedToSendBufferException
	{
		DataBufferOutputStream buffer = bufferService.obtainBuffer();
		if (buffer != null)
		{
			boolean wrote = false;
			try
			{
				int timestamp = getTimeOffset();
				int threadId = threadIdMapper.getCurrent();
				methodIdAdapter.mark(methodId, buffer);
				messageProtocol.writeMethodEntry(buffer, timestamp, sequencer.getSequence(),
						methodId, threadId);
				wrote = true;
			}
			finally
			{
				if (!wrote)
					buffer.reset();
				bufferService.sendBuffer(buffer);
			}
		}
	}

	/**
	 * METHOD EXIT (EVENT) MESSAGE
	 *
	 * @param methodId
	 * @param exThrown
	 * @throws IOException
	 * @throws FailedToObtainBufferException
	 * @throws FailedToSendBufferException
	 */
	public void sendMethodExit(int methodId, boolean exThrown) throws IOException,
			FailedToObtainBufferException, FailedToSendBufferException
	{
		DataBufferOutputStream buffer = bufferService.obtainBuffer();
		if (buffer != null)
		{
			boolean wrote = false;
			try
			{
				int timestamp = getTimeOffset();
				int threadId = threadIdMapper.getCurrent();
				methodIdAdapter.mark(methodId, buffer);
				messageProtocol.writeMethodExit(buffer, timestamp, sequencer.getSequence(),
						methodId, exThrown, threadId);
				wrote = true;
			}
			finally
			{
				if (!wrote)
					buffer.reset();
				bufferService.sendBuffer(buffer);
			}
		}
	}

	private class MethodIdAdapter
	{
		private final ClassIdentifier classIdentifier;
		private final MethodIdentifier methodIdentifier;

		private final ConcurrentMap<Integer, Boolean> observedIds = new ConcurrentHashMap<Integer, Boolean>();

		public MethodIdAdapter(ClassIdentifier classIdentifier, MethodIdentifier methodIdentifier)
		{
			this.classIdentifier = classIdentifier;
			this.methodIdentifier = methodIdentifier;
		}

		public void mark(int methodId, DataBufferOutputStream buffer) throws IOException, FailedToObtainBufferException, FailedToSendBufferException
		{
			Boolean seen = observedIds.putIfAbsent(methodId, true);

			if (seen == null || !seen)
			{
				MethodIdentifier.MethodInformation m = methodIdentifier.get(methodId);
				ClassIdentifier.ClassInformation c = classIdentifier.get(m.getClassId());

				String signature = c.getName() + "." + m.getName() + ";" + m.getAccess() + ";" + m.getDescriptor();
				messageProtocol.writeMapMethodSignature(buffer, methodId, signature);
			}
		}
	}

	private class ExceptionId
	{
		private final AtomicInteger idGen = new AtomicInteger(1);
		private final ConcurrentMap<String, Integer> ids = new ConcurrentHashMap<String, Integer>();

		public int getId(String exception) throws IOException, FailedToObtainBufferException,
				FailedToSendBufferException
		{
			Integer id = ids.putIfAbsent(exception, 0);
			if (id == null || id == 0)
			{
				id = idGen.getAndIncrement();
				if (ids.replace(exception, 0, id))
				{
					sendMapException(exception, id);
				}
			}
			return ids.get(exception);
		}
	}

	/**
	 * Creates a monotonically-incrementing unique id for each thread. The id
	 * for the currently-running thread is available via {@link #getCurrent()}
	 *
	 * @author dylanh
	 *
	 */
	private class ThreadId
	{
		/**
		 * Creates a new, unique id for each thread, on demand.
		 */
		private final ThreadLocal<Integer> threadId = new ThreadLocal<Integer>()
		{
			private final AtomicInteger uniqueId = new AtomicInteger(0);

			@Override
			protected Integer initialValue()
			{
				return uniqueId.getAndIncrement();
			};
		};

		/**
		 * Per-thread storage of whether or not a thread has a `threadId`
		 * association. The `getCurrent` method will perform a check and update
		 * using this.
		 */
		private final ThreadLocal<Boolean> threadHasId = new ThreadLocal<Boolean>()
		{
			@Override
			protected Boolean initialValue()
			{
				return false;
			};
		};

		/**
		 * Stores the latest known name of a thread. Updated by `getCurrent`.
		 */
		private final ThreadLocal<String> threadName = new ThreadLocal<String>()
		{
			@Override
			protected String initialValue()
			{
				return Thread.currentThread().getName();
			};
		};

		/**
		 * Get the unique id of the currently-running thread. When necessary,
		 * this method will automatically send a MapMethodName message to the
		 * message queue.
		 *
		 * @return The unique id for the currently-running thread.
		 * @throws InterruptedException
		 * @throws IOException
		 * @throws FailedToSendBufferException
		 * @throws FailedToObtainBufferException
		 */
		public int getCurrent() throws IOException, FailedToObtainBufferException,
				FailedToSendBufferException
		{
			boolean updated = false;
			int id = threadId.get();

			// check if the id is "new"
			if (!threadHasId.get())
			{
				threadHasId.set(true);
				updated = true;
			}

			// check if the name has changed
			String oldName = threadName.get();
			if (oldName == null)
				oldName = "";
			String nowName = Thread.currentThread().getName();
			if (nowName == null)
				nowName = "";

			if (!nowName.equals(oldName))
			{
				threadName.set(nowName);
				updated = true;
			}

			// when updated, send a MapThreadName message
			if (updated)
			{
				sendMapThreadName(nowName, id);
			}
			return id;
		}
	}

	/**
	 * Provides an incrementing sequence counter for events.
	 *
	 * @author RobertF
	 *
	 */
	private class Sequencer
	{
		private final AtomicInteger sequenceId = new AtomicInteger();

		/**
		 * Get a new (unique) sequence identifier.
		 *
		 * @return current sequence value
		 */
		public int getSequence()
		{
			return sequenceId.getAndIncrement();
		}

		/**
		 * Observes the current sequence identifier, without modifying it.
		 *
		 * @return the next sequence value
		 */
		public int observeSequence()
		{
			return sequenceId.get();
		}
	}
}
